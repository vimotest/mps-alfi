#!/usr/bin/env python3
"""
This script is generated by Claude Opus 4.5.

Script to identify and delete GitHub releases and tags with -alpha<number> or -beta<number> suffixes.

IMPORTANT: This script requires manual confirmation for EACH deletion.
It will NEVER delete multiple items at once.

Token: goto https://github.com/settings/personal-access-tokens/new and generate token with scope 'Contents' read/write.

Requirements:
    pip install PyGithub

Usage:
    export GITHUB_TOKEN="your_token_here"
    python remove_alpha_beta_releases.py <owner>/<repo>

Example:
    python remove_alpha_beta_releases.py vimotest/mps-vimotest
"""

import os
import re
import sys
import subprocess
from github import Github, GithubException

# Pattern to match -alpha<number> or -beta<number> suffixes
ALPHA_BETA_PATTERN = re.compile(r'-(alpha|beta)\d+$', re.IGNORECASE)


def get_github_client():
    """Create GitHub client from environment token."""
    token = os.environ.get('GITHUB_TOKEN')
    if not token:
        print("ERROR: GITHUB_TOKEN environment variable is not set!")
        print("Please set it with: export GITHUB_TOKEN='your_token_here'")
        sys.exit(1)
    return Github(token)


def is_alpha_or_beta(tag_name: str) -> bool:
    """Check if tag name ends with -alpha<number> or -beta<number>."""
    return bool(ALPHA_BETA_PATTERN.search(tag_name))


def fetch_all_releases(repo):
    """Fetch all releases from the repository."""
    print(f"\n{'='*60}")
    print("Fetching all releases from repository...")
    print(f"{'='*60}\n")

    releases = list(repo.get_releases())
    print(f"Total releases found: {len(releases)}")
    return releases


def fetch_all_tags(repo):
    """Fetch all tags from the repository."""
    print(f"\n{'='*60}")
    print("Fetching all tags from repository...")
    print(f"{'='*60}\n")

    tags = list(repo.get_tags())
    print(f"Total tags found: {len(tags)}")
    return tags


def identify_alpha_beta_releases(releases):
    """Filter releases that match alpha/beta pattern."""
    matching = []
    for release in releases:
        if is_alpha_or_beta(release.tag_name):
            matching.append(release)
    return matching


def identify_alpha_beta_tags(tags):
    """Filter tags that match alpha/beta pattern."""
    matching = []
    for tag in tags:
        if is_alpha_or_beta(tag.name):
            matching.append(tag)
    return matching


def log_identified_items(releases, tags):
    """Log all identified alpha/beta releases and tags."""
    print(f"\n{'='*60}")
    print("IDENTIFIED ALPHA/BETA RELEASES")
    print(f"{'='*60}")

    if not releases:
        print("  (none found)")
    else:
        for i, release in enumerate(releases, 1):
            print(f"  {i:3d}. Release: {release.tag_name}")
            print(f"       Title: {release.title}")
            print(f"       Created: {release.created_at}")
            print(f"       Draft: {release.draft}, Prerelease: {release.prerelease}")
            print()

    print(f"\n{'='*60}")
    print("IDENTIFIED ALPHA/BETA TAGS (without RELEASES)")
    print(f"{'='*60}")

    # Find tags that don't have a corresponding release
    release_tag_names = {r.tag_name for r in releases}
    orphan_tags = [t for t in tags if t.name not in release_tag_names]

    if not orphan_tags:
        print("  (none found - all alpha/beta tags have releases)")
    else:
        for i, tag in enumerate(orphan_tags, 1):
            print(f"  {i:3d}. Tag: {tag.name}")
            print(f"       SHA: {tag.commit.sha[:12]}")
            print()

    return orphan_tags


def confirm_deletion(item_type: str, item_name: str) -> bool:
    """Ask user for confirmation before deleting."""
    print(f"\n{'*'*60}")
    print(f"* CONFIRM DELETION")
    print(f"* Type: {item_type}")
    print(f"* Name: {item_name}")
    print(f"{'*'*60}")
    print()

    while True:
        response = input(f"Delete {item_type} '{item_name}'? [y/n/q] (y=yes, n=no, q=quit): ").strip().lower()
        if response == 'y':
            return True
        elif response == 'n':
            print(f"  -> SKIPPED: {item_name}")
            return False
        elif response == 'q':
            print("\n  -> User requested QUIT. Exiting...")
            sys.exit(0)
        else:
            print("  Please enter 'y' for yes, 'n' for no, or 'q' to quit.")


def delete_release(release) -> bool:
    """Delete a single release after confirmation."""
    try:
        release.delete_release()
        print(f"  -> DELETED release: {release.tag_name}")
        return True
    except GithubException as e:
        print(f"  -> ERROR deleting release {release.tag_name}: {e}")
        return False


def delete_tag(repo, tag_name: str) -> bool:
    """Delete a single tag (git ref) after confirmation."""
    try:
        ref = repo.get_git_ref(f"tags/{tag_name}")
        ref.delete()
        print(f"  -> DELETED tag: {tag_name}")
        return True
    except GithubException as e:
        print(f"  -> ERROR deleting tag {tag_name}: {e}")
        return False


def process_releases_and_tags(repo, releases, tags):
    """Process destruction of releases and tags."""
    deleted_rels = 0
    skipped_rels = 0
    deleted_tags = 0
    skipped_tags = 0

    # Process Releases
    if releases:
        print(f"\n{'#'*60}")
        print("# PROCESSING RELEASES")
        print(f"{'#'*60}")

        for i, release in enumerate(releases, 1):
            print(f"\n[RELEASE {i}/{len(releases)}]")
            # Ask for confirmation for the Release (and implicitly the tag)
            if confirm_deletion("RELEASE + TAG", release.tag_name):
                # Try to delete Release
                if delete_release(release):
                    deleted_rels += 1

                # Always try to delete the tag as well
                if delete_tag(repo, release.tag_name):
                    deleted_tags += 1
            else:
                skipped_rels += 1
                # We skip tag too if release is skipped

    # Process Orphan Tags
    if tags:
        print(f"\n{'#'*60}")
        print("# PROCESSING ORPHAN TAGS")
        print(f"{'#'*60}")

        for i, tag in enumerate(tags, 1):
            print(f"\n[TAG {i}/{len(tags)}]")
            if confirm_deletion("TAG", tag.name):
                if delete_tag(repo, tag.name):
                    deleted_tags += 1
                else:
                    skipped_tags += 1
            else:
                skipped_tags += 1

    return deleted_rels, deleted_tags, skipped_rels, skipped_tags


def print_summary(deleted_releases, deleted_tags, skipped_releases, skipped_tags):
    """Print final summary."""
    print(f"\n{'='*60}")
    print("SUMMARY")
    print(f"{'='*60}")
    print(f"  Releases deleted: {deleted_releases}")
    print(f"  Releases skipped: {skipped_releases}")
    print(f"  Tags deleted:     {deleted_tags}")
    print(f"  Tags skipped:     {skipped_tags}")
    print(f"{'='*60}\n")


def get_local_tags():
    """Fetch all local tags using git."""
    try:
        # Run git tag
        result = subprocess.run(['git', 'tag'], capture_output=True, text=True, check=True)
        # Split by newline and filter empty strings
        tags = [t.strip() for t in result.stdout.split('\n') if t.strip()]
        return tags
    except subprocess.CalledProcessError:
        print("Warning: Could not list local tags (git command failed).")
        return []
    except FileNotFoundError:
        print("Warning: git command not found.")
        return []


def delete_local_tag_git(tag_name: str) -> bool:
    """Delete a single local tag using git."""
    try:
        subprocess.run(['git', 'tag', '-d', tag_name], check=True, capture_output=True)
        print(f"  -> DELETED local tag: {tag_name}")
        return True
    except subprocess.CalledProcessError as e:
        print(f"  -> ERROR deleting local tag {tag_name}: {e}")
        return False


def cleanup_local_tags():
    """Identify and delete local alpha/beta tags."""
    print(f"\n{'='*60}")
    print("LOCAL TAG CLEANUP")
    print(f"{'='*60}")

    local_tags = get_local_tags()
    matching_tags = [t for t in local_tags if is_alpha_or_beta(t)]

    if not matching_tags:
        print("No local alpha/beta tags found.")
        return

    print(f"Found {len(matching_tags)} local alpha/beta tags.")
    print("These exist in your local git repository.")

    print("Identified local tags:")
    for i, tag in enumerate(matching_tags, 1):
        print(f"  {i}. {tag}")

    # Ask for confirmation once for all local tags
    print("\nSince these are local tags, we can batch delete them.")
    response = input(f"Delete ALL {len(matching_tags)} local tags? [y/n] (y=yes, n=no): ").strip().lower()

    deleted_count = 0
    skipped_count = 0

    if response == 'y':
        print(f"\n{'#'*60}")
        print("# DELETING LOCAL TAGS")
        print(f"{'#'*60}")

        for i, tag in enumerate(matching_tags, 1):
            if delete_local_tag_git(tag):
                deleted_count += 1
            else:
                skipped_count += 1
    else:
        print("Skipping local tag deletion.")
        skipped_count = len(matching_tags)

    print(f"\nLocal Tags Summary: Deleted: {deleted_count}, Skipped: {skipped_count}")


def main():
    if len(sys.argv) != 2:
        print("Usage: python remove_alpha_beta_releases.py <owner>/<repo>")
        print("Example: python remove_alpha_beta_releases.py vimotest/mps-vimotest")
        sys.exit(1)

    repo_name = sys.argv[1]

    print(f"\n{'='*60}")
    print("ALPHA/BETA RELEASE CLEANUP SCRIPT")
    print(f"{'='*60}")
    print(f"Repository: {repo_name}")
    print(f"Pattern: Tags/Releases ending with -alpha<number> or -beta<number>")
    print()
    print("WARNING: This script will DELETE releases and tags!")
    print("         Each deletion requires YOUR confirmation.")
    print("         Press 'q' at any prompt to quit safely.")
    print(f"{'='*60}")

    # Connect to GitHub
    gh = get_github_client()

    try:
        repo = gh.get_repo(repo_name)
        print(f"\nConnected to: {repo.full_name}")
        print(f"Description: {repo.description}")
    except GithubException as e:
        print(f"ERROR: Could not access repository '{repo_name}': {e}")
        sys.exit(1)

    # Fetch all releases and tags
    all_releases = fetch_all_releases(repo)
    all_tags = fetch_all_tags(repo)

    # Identify alpha/beta items
    alpha_beta_releases = identify_alpha_beta_releases(all_releases)
    alpha_beta_tags = identify_alpha_beta_tags(all_tags)

    # Log what was found
    orphan_tags = log_identified_items(alpha_beta_releases, alpha_beta_tags)

    # Summary before processing
    total_items = len(alpha_beta_releases) + len(orphan_tags)
    print(f"\n{'='*60}")
    print(f"TOTAL REMOTE ITEMS TO PROCESS: {total_items}")
    print(f"  - Releases: {len(alpha_beta_releases)}")
    print(f"  - Orphan tags: {len(orphan_tags)}")
    print(f"{'='*60}")

    if total_items > 0:
        # Final confirmation before starting
        print("\nYou will be asked to confirm EACH deletion individually.")
        input("Press ENTER to start processing REMOTE items, or Ctrl+C to abort... ")

        # Process one by one
        deleted_releases, deleted_tags, skipped_releases, skipped_tags = \
            process_releases_and_tags(repo, alpha_beta_releases, orphan_tags)

        # Print summary
        print_summary(deleted_releases, deleted_tags, skipped_releases, skipped_tags)
    else:
        print("\nNo remote alpha/beta releases or tags found.")

    # Process local tags
    cleanup_local_tags()

    print("Done!")


if __name__ == "__main__":
    main()

